"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.replaceWaiterApi = void 0;
const getArgsWithoutWaiterConfig_1 = require("./getArgsWithoutWaiterConfig");
const getClientWaiterCallExpression_1 = require("./getClientWaiterCallExpression");
const getClientWaiterStates_1 = require("./getClientWaiterStates");
const getV3ClientWaiterApiName_1 = require("./getV3ClientWaiterApiName");
const getWaiterConfig_1 = require("./getWaiterConfig");
const getWaiterConfigValue_1 = require("./getWaiterConfigValue");
// Updates .waitFor() API with waitUntil* API.
const replaceWaiterApi = (j, source, clientIdentifiers) => {
    for (const clientId of clientIdentifiers) {
        const waiterStates = (0, getClientWaiterStates_1.getClientWaiterStates)(j, source, clientIdentifiers);
        for (const waiterState of waiterStates) {
            source
                .find(j.CallExpression, (0, getClientWaiterCallExpression_1.getClientWaiterCallExpression)(clientId, waiterState))
                .replaceWith((callExpression) => {
                let delay;
                let maxAttempts;
                const callArguments = callExpression.node.arguments;
                if (callArguments.length > 1 && callArguments[1].type === "ObjectExpression") {
                    const waiterConfig = (0, getWaiterConfig_1.getWaiterConfig)(callArguments[1]);
                    if (waiterConfig) {
                        delay = (0, getWaiterConfigValue_1.getWaiterConfigValue)(waiterConfig, "delay");
                        maxAttempts = (0, getWaiterConfigValue_1.getWaiterConfigValue)(waiterConfig, "maxAttempts");
                    }
                }
                const properties = [];
                properties.push(j.objectProperty.from({
                    key: j.identifier("client"),
                    value: clientId,
                    shorthand: true,
                }));
                if (delay) {
                    properties.push(j.objectProperty.from({
                        key: j.identifier("minDelay"),
                        value: j.numericLiteral(Number(delay)),
                    }));
                }
                const delayForWaitTime = delay ? Number(delay) : 10;
                const maxAttemptsForWaitTime = maxAttempts ? Number(maxAttempts) : 10;
                const maxWaitTime = 2 * delayForWaitTime * maxAttemptsForWaitTime;
                properties.push(j.objectProperty.from({
                    key: j.identifier("maxWaitTime"),
                    value: j.numericLiteral(maxWaitTime),
                }));
                const options = callExpression.node.arguments[1];
                const updatedOptions = options.type === "ObjectExpression" ? (0, getArgsWithoutWaiterConfig_1.getArgsWithoutWaiterConfig)(options) : options;
                return j.callExpression(j.identifier((0, getV3ClientWaiterApiName_1.getV3ClientWaiterApiName)(waiterState)), [
                    j.objectExpression(properties),
                    updatedOptions,
                ]);
            });
        }
    }
};
exports.replaceWaiterApi = replaceWaiterApi;
